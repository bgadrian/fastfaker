// +build ignore

//this file generates the handlers/custom_keys.go file
//use go generate to update it

package main

import (
	"fmt"
	"html/template"
	"log"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"

	"github.com/bgadrian/fastfaker/faker"
)

func main() {

	if len(os.Args) != 2 {
		log.Panicf("requires one parameter, of ['go', 'markdown']")
	}

	type funct struct {
		Key, Call, Example string
	}
	list := make([]funct, 0, 100)

	fastFaker := faker.NewFastFaker()
	fastFaker.Seed(42)
	fakerType := reflect.TypeOf(fastFaker)
	fakerValue := reflect.ValueOf(fastFaker)

	countOfMethods := fakerType.NumMethod()
	for i := 0; i < countOfMethods; i++ {
		method := fakerType.Method(i)

		//here we only collect simple functions, no parameters
		//the first parameter is the actual struct (because is a method)
		if method.Type.NumIn() > 1 {
			continue
		}

		var example string

		call := "f." + method.Name
		g := byte('g')

		res := fakerValue.Method(i).Call([]reflect.Value{})
		if len(res) != 1 {
			log.Panicf("weird method: %s", fakerValue.Method(i).String())
		}
		switch res[0].Interface().(type) {
		case string:
			example = res[0].String()
			call = fmt.Sprintf("func(f *Faker) string { return %s() }", call)
		case int:
			example = strconv.Itoa(int(res[0].Int()))
			call = fmt.Sprintf("func(f *Faker) string { return strconv.Itoa(%s()) }", call)
		case int8, int16, int32, int64:
			example = strconv.Itoa(int(res[0].Int()))
			call = fmt.Sprintf("func(f *Faker) string { return strconv.Itoa(int(%s())) }", call)
		case uint8, uint16, uint32, uint64:
			example = strconv.Itoa(int(res[0].Uint()))
			call = fmt.Sprintf("func(f *Faker) string { return strconv.Itoa(int(%s())) }", call)
		case float32:
			example = strconv.FormatFloat(float64(res[0].Float()), 'g', -1, 32)
			call = fmt.Sprintf("func(f *Faker) string { return strconv.FormatFloat(float64(%s()), %d, -1, 32) }", call, g)
		case float64:
			example = strconv.FormatFloat(float64(res[0].Float()), 'g', -1, 64)
			call = fmt.Sprintf("func(f *Faker) string { return strconv.FormatFloat(%s(), %d, -1, 64) }", call, g)
		default:
			continue
			//example = fmt.Sprintf("%v", res[0])
			//bytes, err := json.Marshal(res[0])
			//if err != nil {
			//	log.Panic(err)
			//}
			//example = string(bytes)
		}

		list = append(list, funct{
			Key:     strings.ToLower(method.Name),
			Call:    call,
			Example: strings.Replace(example, "\n", " ", -1),
		})
	}

	sort.Slice(list, func(i, j int) bool {
		return list[i].Key < list[j].Key
	})

	//TODO learn how to use the go generate

	if os.Args[1] == "go" {
		packageTemplate.Execute(os.Stdout, list)
	} else {
		readmeTemplate.Execute(os.Stdout, list)
	}
}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by make generate DO NOT EDIT.

package faker

import (
	"strconv"
)

type fakerer func(*Faker) string

var templateVariables map[string]fakerer

func init() {
	templateVariables = getTemplateVars()
}

func getTemplateVars() map[string]fakerer {
	vars := make(map[string]fakerer, 100)
	
	{{range .}}vars["{{.Key}}"] = {{.Call}}
	{{end}}
	return vars
}// Code generated by make generate DO NOT EDIT.

`))

var readmeTemplate = template.Must(template.New("").Parse(`# FastFaker Templates

This document contains all the available variables, with examples that can be used with the Faker.Template, Faker.TemplateCustom and Faker.Struct methods.

A variable is an alias to the public Faker method with the same name, for example:
* **&#123;name&#125;** will be replaced by the result from Faker.Name() method
* **&#123;hackernoun&#125;** will be replaced by the result from Faker.HackerNoun() method

> Note: the Faker.Template() function has 2 more special characters: '#' and '?', they will be replaced by a digit or an ASCII lowercase letter. If you do want this functionality use Faker.TemplateCustom().

For more info see [TEMPLATES](./TEMPLATES.md).

| Variable | Example |
|---------|--------|
{{range .}}| **&#123;{{.Key}}&#125;** | {{.Example}} |
{{end}}


> This file is generated automatically at build.

`))
